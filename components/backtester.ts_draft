import fs from 'fs';
import path from 'path';

try {
    interface IAggTrades {
        price: number;
        quantity: number;
        buysell: number;
        count: number;
        deltaPricePerc: number;
        deltaQuantPerc: number;
    };

    class TradesBackTest {
        name: string;
        data: {
            [key: number]: number[][]
        };
        balance: number;
        comission: number;
        lots: number;
        keys: string[];
        assets: {
            time: number;
            price: number;
            lot: number;
        }[];
        aggregated: IAggTrades[];
        sellDelta: number;
        buyStepDelta: number;
        prevTradesLen: number;
        tradesCount: number;
        compareBuyPrice: number;
        compareSellPrice: number;
        compareBuySellPrice: number;
        compareBuySellQuant: number;
        compareBuyPriceForSell: number;
        compareSellPriceForSell: number;
        compareBuySellPriceForSell: number;
        compareBuySellQuantForSell: number;
        buyCnt: number;
        sellCnt: number;

        constructor(name: string, options: {
            sellDelta: number;
            buyStepDelta: number;
            prevTradesLen: number;

            compareBuyPrice: number;
            compareSellPrice: number;
            compareBuySellPrice: number;
            compareBuySellQuant: number;

            compareBuyPriceForSell: number;
            compareSellPriceForSell: number;
            compareBuySellPriceForSell: number;
            compareBuySellQuantForSell: number;
        }) {
            this.sellDelta = options.sellDelta;
            this.buyStepDelta = options.buyStepDelta;
            this.prevTradesLen = options.prevTradesLen;

            this.compareBuyPrice = options.compareBuyPrice;
            this.compareSellPrice = options.compareSellPrice;
            this.compareBuySellPrice = options.compareBuySellPrice;
            this.compareBuySellQuant = options.compareBuySellQuant;

            this.compareBuyPriceForSell = options.compareBuyPriceForSell;
            this.compareSellPriceForSell = options.compareSellPriceForSell;
            this.compareBuySellPriceForSell = options.compareBuySellPriceForSell;
            this.compareBuySellQuantForSell = options.compareBuySellQuantForSell;

            this.name = name;

            this.data = JSON.parse(fs.readFileSync(path.resolve(__dirname, path.join('truejson', `${name}\.json`))).toString());

            this.balance = 100000;
            this.comission = 0.0005;
            this.assets = [];

            this.lots = 1;

            Object.keys(this.data).forEach((d: string) => {
                const t = new Date();
                t.setMonth(t.getMonth() - 1);

                if (Number(d) < t.getTime()) {
                    delete this.data[Number(d)];
                }
            });

            // console.log(Object.keys(this.data).length);
            this.buyCnt = 0;
            this.sellCnt = 0;

            this.keys = Object.keys(this.data);
            let price = this.data[Number(this.keys[0])][0][1];
            let startPrice = price;

            while (price < 1000) {
                this.lots *= 10;
                price = startPrice * this.lots;
            }

            this.tradesCount = 0;
            this.aggregated = [];
            // console.log(this.lots, price, startPrice);
        }

        backtest() {
            let profitDays = 0;
            let downDays = 0;

            for (let j = 0; j < this.keys.length; j++) {
                const k = Number(this.keys[j]);

                let startPrice: number = 0;
                let endPrice: number = 0;

                // const lenPrevTrade = 10;

                // const sPrice = this.data[k][0][1] * this.lots;
                // const ePrice = this.data[k][this.data[k].length - 1][1] * this.lots;

                // if (((sPrice - ePrice) / sPrice) > 0.005) {
                //     profitDays += (sPrice - ePrice) / sPrice;
                //     console.log(sPrice, ePrice, ((sPrice - ePrice) / sPrice).toFixed(4));
                // } else if (((sPrice - ePrice) / sPrice) < -0.005) {
                //     downDays += (sPrice - ePrice) / sPrice;
                //     console.log(sPrice, ePrice, ((sPrice - ePrice) / sPrice).toFixed(4));
                // }

                if (this.data[k].length <= 1) {
                    continue;
                }

                for (let i = 0; i < this.data[k].length; i++) {
                    const time = this.data[k][i][0];
                    const price = this.data[k][i][1] * this.lots;
                    const quantity = this.data[k][i][2];
                    const buysell = this.data[k][i][3];


                    // console.log(j, i, new Date(time).toLocaleTimeString(), buysell, price.toFixed(2), quantity);
                    const prevTradesAll = this.agregatePrevTrades(this.data[k][i]);

                    // if (prevTradesAll.length > this.prevTradesLen) {

                    const prevTrades = prevTradesAll.slice(prevTradesAll.length - this.prevTradesLen);

                    // if (Math.abs((sPrice - ePrice) / sPrice) > 0.005) {
                    //     console.log(price, quantity, buysell);
                    //     console.log(this.agregatePrevTrades(this.data[k]));
                    // }

                    // console.log(prevTrades);

                    // if (!i) {
                    //     startPrice = price;
                    //     this.sell(price, 1);
                    // } else if (i === this.data[k].length - 1) {
                    //     endPrice = price;
                    //     console.log('this.data[k]', this.data[k][i]);
                    //     this.buy(price, 1);
                    // } 
                    // // else {
                    //     console.log(i, this.data[k].length - 1);
                    // }

                    if (this.needBuy(prevTrades, price)) {
                        startPrice = price;

                        // this.buyCompare(prevTrades);

                        this.buy(price, 1);
                        ++this.buyCnt;
            
                        // console.log('buy', price, this.balance);
                    } else if (this.needSell(prevTrades, price)) {
                        endPrice = price;
                        this.sell(price, 1);
                        this.sellCnt++;

                        // console.log('sell', price, this.balance);
                    }

                    // }

                    // console.log(i, this.data[k].length - 1, this.data[k].length)
                }

                // console.log();

                // console.log('balance', this.balance, 'start', startPrice, 'end', endPrice, '|||', startPrice - endPrice, this.assets.length);
            }


            if (//j === this.keys.length - 1 && 
                this.assets.length) {
                const k = Number(this.keys[this.keys.length - 1]);
                const price = this.data[k][this.data[k].length - 1][1] * this.lots;

                do {
                    this.inShort() ?
                        this.buy(price, 1) :
                        this.sell(price, 1);
                    // console.log('sell last', price, this.balance);
                } while (this.assets.length);
            }

            // console.log('profitDays', profitDays, 'downDays', downDays);
            console.log('balance', this.balance); // , 'start', startPrice, 'end', endPrice, '|||', startPrice - endPrice);

            return this.balance;
        }

        getTradesCount() {
            return this.tradesCount;
        }

        agregatePrevTrades(trade: number[]) {
            const price = trade[1] * this.lots;
            const quantity = trade[2];
            const buysell = trade[3];

            if (!this.aggregated?.length) {
                this.aggregated.push({
                    price,
                    quantity,
                    buysell,
                    count: 1,
                    deltaPricePerc: 0,
                    deltaQuantPerc: 0,
                });

                return this.aggregated;
            }

            const aggregated = this.aggregated;
            const last = aggregated[aggregated.length - 1];

            if (last.buysell === buysell) {
                last.quantity += quantity;
                last.count += 1;
            } else {
                aggregated.push({
                    price,
                    quantity,
                    buysell,
                    count: 1,
                    deltaPricePerc: (price - last.price) / price,
                    deltaQuantPerc: 0, // (quantity - last.quantity) / quantity,
                });
            }

            return aggregated;
        }

        getFiFoPrice() {
            if (this.assets.length) {
                return this.assets[0].price;
            }
        }

        getLastPrice() {
            if (this.assets.length) {
                return this.assets[this.assets.length - 1].price;
            }
        }

        getAvgPrice() {
            return this.assets.reduce((acc, val) => {
                return acc + val.price;
            }, 0) / this.assets.length;
        }

        needBuy(prevTrades: IAggTrades[], currentPrice: number) {
            // const startPrice = prevTrades[0].price;
            // const endPrice = prevTrades[prevTrades.length - 1].price;
            if (this.assets.length) {
                const lastPrice = this.getAvgPrice();
                if (this.inShort()) {
                    if (this.inShort() && currentPrice <= lastPrice / this.sellDelta) {
                        return true;
                    }
                } else {
                    return false;
                }

                // if (lastPrice) {
                //     if ((lastPrice - currentPrice) / lastPrice > this.buyStepDelta) {
                //         // console.log(lastPrice, currentPrice, (lastPrice - currentPrice) / lastPrice);
                //         // return prevTrades.every((p) => p[3] === 1);

                //         return this.buyCompare(prevTrades); // prevTrades.every(p => p.deltaPricePerc >= 0);
                //     }
                // }

                return false;
            }

            return this.buyCompare(prevTrades);


            // return endPrice > startPrice && prevTrades.every((p) => p[3] === 2) && prevTrades.every((p) => p[2] > 50);
            // return (endPrice - startPrice) / endPrice > 0.0005 && prevTrades.every((p) => p[3] === 2);
        }

        buyCompare(prevTrades: IAggTrades[]) {
            const data = prevTrades.reduce((acc, val) => {
                const {
                    buysell,
                    count,
                    deltaPricePerc,
                    quantity,
                } = val;

                if (buysell === 1) {
                    acc.buy.deltaPricePerc += deltaPricePerc;
                    acc.buy.quantity += quantity;
                    acc.buy.count += count;
                    acc.buy.cnt++;
                } else {
                    acc.sell.deltaPricePerc += deltaPricePerc;
                    acc.sell.quantity += quantity;
                    acc.sell.count += count;
                    acc.sell.cnt++;
                }

                return acc;
            }, {
                buy: {
                    deltaPricePerc: 0,
                    count: 0,
                    quantity: 0,
                    cnt: 0,
                },
                sell: {
                    deltaPricePerc: 0,
                    count: 0,
                    quantity: 0,
                    cnt: 0,
                }
            });

            const buyPrice = (((((data.buy.deltaPricePerc / data.buy.cnt) * 10000 * 100))));
            const buyQuant = ((((data.buy.quantity / data.buy.count))));
            const sellPrice = (((((data.sell.deltaPricePerc / data.sell.cnt) * 10000 * 100))));
            const sellQuant = ((((data.sell.quantity / data.sell.count))));

            // console.log(buyPrice, sellPrice, buyQuant, sellQuant)

            if (
                buyPrice > this.compareBuyPrice &&
                sellPrice < this.compareSellPrice &&
                buyPrice > (sellPrice * this.compareBuySellPrice) &&
                buyQuant > (sellQuant * this.compareBuySellQuant)
            ) {
                return true;
            }
        }

        inShort() {
            return !!(this.assets.length && this.assets[0].lot < 0);
        }

        needSell(prevTrades: any[], currentPrice: number) {
            if (this.assets.length) {
                if (!this.inShort()) {
                    const avg = this.getAvgPrice();
                    if (currentPrice >= avg * this.sellDelta) {
                        return true;
                    }
                } else {
                    return false;
                }
                // return false;
            }


            // const positionPrice = this.getFiFoPrice();

            // if (!positionPrice) {
            //     return false;
            // }

            // console.log(currentPrice, avg, currentPrice > avg * 1.005);


            return this.sellCompare(prevTrades);
            // const startPrice = prevTrades[0][1];
            // const endPrice = prevTrades[prevTrades.length - 1][1];

            // return startPrice > endPrice && prevTrades.every((p) => p[3] === 2);
        }

        sellCompare(prevTrades: IAggTrades[]) {
            const data = prevTrades.reduce((acc, val) => {
                const {
                    buysell,
                    count,
                    deltaPricePerc,
                    quantity,
                } = val;

                if (buysell === 1) {
                    acc.buy.deltaPricePerc += deltaPricePerc;
                    acc.buy.quantity += quantity;
                    acc.buy.count += count;
                    acc.buy.cnt++;
                } else {
                    acc.sell.deltaPricePerc += deltaPricePerc;
                    acc.sell.quantity += quantity;
                    acc.sell.count += count;
                    acc.sell.cnt++;
                }

                return acc;
            }, {
                buy: {
                    deltaPricePerc: 0,
                    count: 0,
                    quantity: 0,
                    cnt: 0,
                },
                sell: {
                    deltaPricePerc: 0,
                    count: 0,
                    quantity: 0,
                    cnt: 0,
                }
            });

            const buyPrice = (((((data.buy.deltaPricePerc / data.buy.cnt) * 10000 * 100))));
            const buyQuant = ((((data.buy.quantity / data.buy.count))));
            const sellPrice = (((((data.sell.deltaPricePerc / data.sell.cnt) * 10000 * 100))));
            const sellQuant = ((((data.sell.quantity / data.sell.count))));


            if (
                buyPrice < this.compareBuyPriceForSell &&
                sellPrice > this.compareSellPriceForSell &&
                (buyPrice * this.compareBuySellPriceForSell) < sellPrice &&
                (buyQuant * this.compareBuySellQuantForSell) < sellQuant
            ) {
                // console.log(buyPrice, sellPrice, buyQuant, sellQuant)

                return true;
            }
        }

        buy(price: number, lot: number) {
            const allPrice = (price + price * this.comission) * lot;

            if (!this.assets?.length || this.assets[0].lot > 0) {

                if (allPrice > this.balance) {
                    // console.log('Недостаточно средств');
                } else {
                    this.tradesCount++;

                    this.assets.push({
                        time: Date.now(),
                        price,
                        lot,
                    });
                    this.balance -= allPrice;
                }

                return;
            }

            let stayLots = lot;

            while (this.assets.length && stayLots && this.assets[0].lot < 0) {
                const {
                    lot,
                } = this.assets[0];
                let useLots = 0;

                const absLot = Math.abs(lot);

                if (stayLots >= absLot) {
                    stayLots -= absLot;
                    useLots = absLot;
                    this.assets.shift();
                } else {
                    this.assets[0].lot += stayLots;
                    useLots = stayLots;
                    stayLots = 0;
                }

                this.balance -= (price - price * this.comission) * useLots;
            }

            if (stayLots) {
                this.buy(price, lot);
            }
        }

        sell(sellPrice: number, lot: number) {
            // const allPrice = (sellPrice + sellPrice * this.comission) * lot;
            let stayLots = lot;
            const allPrice = (sellPrice + sellPrice * this.comission) * lot;

            if (!this.assets?.length || this.assets[0].lot < 0) {
                // if (allPrice > this.balance * 1.5) {
                if (this.balance + allPrice > 200000) {
                    // console.log('Недостаточно средств');
                    // return;
                } else {
                    this.tradesCount++;

                    this.assets.push({
                        time: Date.now(),
                        price: sellPrice,
                        lot: -lot,
                    });

                    this.balance += allPrice;
                    // return;
                }

                return;
            }

            while (this.assets.length && stayLots && this.assets[0].lot > 0) {
                const {
                    lot,
                } = this.assets[0];
                let useLots = 0;

                if (stayLots >= lot) {
                    stayLots -= lot;
                    useLots = lot;
                    this.assets.shift();
                } else {
                    this.assets[0].lot -= stayLots;
                    useLots = stayLots;
                    stayLots = 0;
                }

                // console.log(sellPrice, sellPrice * this.comission, useLots, (sellPrice - sellPrice * this.comission) * useLots)
                this.balance += (sellPrice - sellPrice * this.comission) * useLots;
            }

            if (stayLots) {
                this.sell(sellPrice, lot);
            }
        }
    }

    console.time('all');
    let name: string | undefined = 'SBER';

    // @ts-ignore
    const files = fs.readdirSync(path.resolve(__dirname, 'truejson')).map(f => f.split(';')[0]).sort((a: string, b: string) => a - b);
    let executing: string[] = [];

    try {
        // @ts-ignore
        executing = fs.readFileSync(path.resolve(__dirname, 'executing')).toString().split('::').sort((a: string, b: string) => a - b);
    } catch (e) {
    }

    if (!executing?.length) {
        name = files[0];
    } else {
        name = files.find(f => !executing.includes(f));
    }

    name = 'OZON';

    if (name) {
        console.log('name', name);

        fs.appendFileSync(path.resolve(__dirname, 'executing'), `::${name}`);

        const balanceResult = [];

        // for (let prevTradesLen = 2; prevTradesLen < 15; prevTradesLen += 5) {
        //     for (let sellDelta = 1.001; sellDelta <= 1.01; sellDelta += 0.004) {
        //         for (let buyStepDelta = 0.001; buyStepDelta <= 0.01; buyStepDelta += 0.004) {

        //             for (let compareBuyPrice = 0; compareBuyPrice <= 30; compareBuyPrice += 10) {
        //                 for (let compareSellPrice = 0; compareSellPrice <= 30; compareSellPrice += 10) {

        //                     for (let compareBuySellPrice = 0; compareBuySellPrice < 15; compareBuySellPrice += 5) {
        //                         for (let compareBuySellQuant = 0; compareBuySellQuant < 15; compareBuySellQuant += 5) {
        // let test = 0;

        for (let compareBuyPrice = 10; compareBuyPrice <= 30; compareBuyPrice += 10) {
            for (let compareSellPrice = 10; compareSellPrice <= 30; compareSellPrice += 10) {

                for (let compareBuySellPrice = 5; compareBuySellPrice <= 10; compareBuySellPrice += 5) {
                    for (let compareBuySellQuant = 5; compareBuySellQuant <= 10; compareBuySellQuant += 5) {


                        for (let compareBuyPriceForSell = 5; compareBuyPriceForSell <= 10; compareBuyPriceForSell += 5) {
                            for (let compareSellPriceForSell = 5; compareSellPriceForSell <= 10; compareSellPriceForSell += 5) {

                                for (let compareBuySellPriceForSell = 10; compareBuySellPriceForSell <= 30; compareBuySellPriceForSell += 10) {
                                    for (let compareBuySellQuantForSell = 10; compareBuySellQuantForSell <= 30; compareBuySellQuantForSell += 10) {

                                        // ++test;
                                        // console.log(test);
                                        // if (1) continue;

                                        // sellDelta [ 1.005, 1.009, 1.001 ]
                                        // buyStepDelta [ 0.005, 0.009, 0.001 ]
                                        // compareBuySellPrice [ 5, 10 ]
                                        // compareBuySellQuant [ 10, 5 ]
                                        // prevTradesLen [ 7, 2, 12 ]
                                        // compareBuyPrice [ 10, 20, 30 ]
                                        // compareSellPrice [ 30, 10, 20 ]

                                        // "sellDelta":1.005,"buyStepDelta":0.005,"compareBuySellPrice":0,"compareBuySellQuant":0,"prevTradesLen":7,"compareBuyPrice":10,"compareSellPrice":0}

                                        const params = {
                                            sellDelta: 1.005,
                                            buyStepDelta: 0.005,
                                            compareBuySellPrice, //: 10,
                                            compareBuySellQuant, // : 10,

                                            prevTradesLen: 10,
                                            compareBuyPrice, //: 20,
                                            compareSellPrice, //: 20,

                                            compareBuyPriceForSell, // : 20,
                                            compareSellPriceForSell, // : 20,
                                            compareBuySellPriceForSell, // : 10,
                                            compareBuySellQuantForSell, // : 10,

                                            // ...{ "sellDelta": 1.005, "buyStepDelta": 0.005, "compareBuySellPrice": 0, "compareBuySellQuant": 0, "prevTradesLen": 7, "compareBuyPrice": 10, "compareSellPrice": 0 }
                                        };

                                        console.time('timeonetest');
                                        const t = new TradesBackTest(name, params);
                                        const balance = Math.floor(t.backtest());
                                        const tradesCount = t.getTradesCount();

                                        console.log(name, params);
                                        console.log(
                                            'balance', balance, 
                                            'tradesCount', tradesCount,
                                            // @ts-ignore
                                            'buyCnt', t.buyCnt, 'sellCnt', t.sellCnt,
                                            Math.floor(((balance - 100000) / 100000) * 10000) / 100);

                                        // @ts-ignore
                                        balanceResult.push([balance, tradesCount, params, t.buyCnt, t.sellCnt]);

                                        // @ts-ignore
                                        fs.writeFileSync(path.resolve(__dirname, path.join('results', `${name};trades.json`)), JSON.stringify(balanceResult.sort((a, b) => b[0] - a[0])));
                                        console.timeEnd('timeonetest');
                                        //         }
                                        //     }
                                        // }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        console.timeEnd('all');

        // @ts-ignore
        balanceResult.sort((a, b) => b[0] - a[0]).slice(0, 10).forEach(q => console.log(q));

    } else {
        console.log('end');
    }

} catch (e) {
    console.log(e);
}
